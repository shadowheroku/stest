import requests
from telegram import Update
from telegram.ext import CommandHandler, MessageHandler, filters, CallbackContext
import random
from hasnainkk import application 
import time

# Global variables for the game
game_word = ""
players = []
current_turn = 0
current_letter = ''
word_length = 3  # Start with 3-letter word
time_limit = 40  # Initial time limit for first round

# Dictionary API URL (replace with your actual dictionary API URL)
DICTIONARY_API_URL = "https://api.dictionaryapi.dev/api/v2/entries/en/"

# Function to fetch a random word that starts with a given letter
def get_random_word(letter, length):
    word = random.choice(['cat', 'dog', 'hat', 'bat', 'rat', 'mat', 'log', 'apple', 'orange'])  # Fallback words
    try:
        response = requests.get(f"{DICTIONARY_API_URL}{letter}")
        if response.status_code == 200:
            words = response.json()
            valid_words = [w['word'] for w in words if w['word'].startswith(letter) and len(w['word']) == length]
            if valid_words:
                word = random.choice(valid_words)
    except Exception as e:
        print(f"Error fetching word: {e}")
    return word

# Function to start the game
async def start_game(update: Update, context: CallbackContext):
    await update.message.reply_text("Welcome to Word Chain Game! Use /join to participate.")

# Function to join the game
async def join_game(update: Update, context: CallbackContext):
    global players
    if update.message.from_user.username not in players:
        players.append(update.message.from_user.username)
        await update.message.reply_text(f"{update.message.from_user.username} has joined the game!")
    else:
        await update.message.reply_text("You have already joined the game.")
    
    if len(players) > 1:
        await update.message.reply_text("Game starting soon. 60 seconds to join!")
        await start_round(update)

# Function to start the first round
async def start_round(update: Update):
    global game_word, current_letter, word_length, time_limit
    current_letter = random.choice('abcdefghijklmnopqrstuvwxyz')  # Random letter for this round
    game_word = get_random_word(current_letter, word_length)  # Get a random word starting with that letter and the correct length
    await update.message.reply_text(f"Game started! The word should start with '{current_letter.upper()}'. Try guessing a {word_length}-letter word.\nYou have {time_limit} seconds!")
    await next_turn(update)

# Function to handle each player's turn
async def next_turn(update: Update):
    global current_turn
    current_player = players[current_turn]
    await update.message.reply_text(f"@{current_player}'s turn! The word starts with '{current_letter.upper()}'. Guess the {word_length}-letter word!")
    
    # Set a timer for player's turn (time_limit seconds)
    context = update.callback_context
    context.job_queue.run_once(time_up, time_limit, context=update.message.chat_id)

    current_turn = (current_turn + 1) % len(players)  # Move to the next player

# Function to handle guesses
async def guess_word(update: Update, context: CallbackContext):
    global game_word, current_turn, current_letter, word_length, time_limit
    guess = update.message.text.lower()
    
    if len(guess) == word_length and guess.startswith(current_letter):  # Ensure word is the right length and starts with the correct letter
        if guess == game_word:
            players.remove(update.message.from_user.username)
            await update.message.reply_text(f"Correct guess! @{update.message.from_user.username} guessed the word correctly!")
            # If all players are eliminated, end the game
            if len(players) == 1:
                await update.message.reply_text(f"{players[0]} wins the game! ðŸŽ‰ðŸŽŠ")
                return
        else:
            await update.message.reply_text("Incorrect guess. Next player's turn.")
        
        # After every round, increase the word length and decrease the time limit
        word_length += 1
        time_limit -= 5  # Decrease time by 5 seconds for each new round
        if time_limit < 5:  # Ensure time does not go below 5 seconds
            time_limit = 5
        # Start the next round
        await start_round(update)
    else:
        await update.message.reply_text(f"Invalid guess. Make sure it's a {word_length}-letter word starting with '{current_letter.upper()}'. Try again.")

# Function for when time runs out
async def time_up(context: CallbackContext):
    global current_turn
    current_player = players[current_turn]
    await context.bot.send_message(context.job.context, f"Time's up for @{current_player}! You are eliminated!")
    players.remove(current_player)
    if len(players) == 1:
        await context.bot.send_message(context.job.context, f"{players[0]} wins the game! ðŸŽ‰ðŸŽŠ")
        return

    # Move to the next player after time is up
    current_turn = (current_turn + 1) % len(players)
    if len(players) > 1:
        await start_round(context.job.context)

# Main function to run the bot


application.add_handler(CommandHandler("classic", start_game))
application.add_handler(CommandHandler("join", join_game))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, guess_word))

    
